Skip to main content
Skip to search
Skip to select language

Open main menu

Glossary
Hoisting


Filter sidebar
Filter
In this article
See also
Glossary
Abstraction
Accent
Accessibility
Accessibility tree
Accessible description
Accessible name
Adobe Flash
Advance measure
Ajax
Algorithm
Alignment container
Alignment subject
Alpha (alpha channel)
ALPN
API
Apple Safari
Application context
Argument
ARIA
ARPA
ARPANET
Array
ASCII
Aspect ratio
Asynchronous
ATAG
Attribute
Authentication
Authenticator
Bandwidth
Base64
Baseline
Beacon
BÃ©zier curve
bfcache
BiDi
BigInt
Binding
Bitwise flags
Blink
blink element (<blink> tag)
Block
Block cipher mode of operation
Block-level content
Boolean
Bounding Box
Breadcrumb
Brotli compression
Browser
Browsing context
Buffer
Cache
Cacheable
CalDAV
Call stack
Callback function
Camel case
Canonical order
Canvas
Card sorting
CardDAV
Caret
CDN
Certificate authority
Certified
Challenge-response authentication
Character
Character encoding
Character reference
Character set
Chrome
CIA
Cipher
Cipher suite
Ciphertext
Class
Clickjacking
Closure
Cloud
Cloud computing
CMS
Code point
Code splitting
Code unit
Codec
Color space
Color wheel
Compile
Compile time
Composite operation
Computer Programming
Conditional
Constant
Constructor
Content header
Continuous Media
Control flow
Cookie
Copyleft
CORS
CORS-safelisted request header
CORS-safelisted response header
Crawler
Credential
CRLF
Cross Axis
Cross-site scripting (XSS)
CRUD
Cryptanalysis
Cryptographic hash function
Cryptography
CSP
CSRF
CSS
CSS Object Model (CSSOM)
CSS pixel
CSS preprocessor
Cumulative Layout Shift (CLS)
Data structure
Database
Debounce
Decryption
Deep copy
Delta
Denial of Service
Deno
Descriptor (CSS)
Deserialization
Developer Tools
Digest
Digital certificate
Digital signature
Distributed Denial of Service
DMZ
DNS
Doctype
Document directive
Document environment
DOM (Document Object Model)
Domain
Domain name
Domain sharding
Dominator
DoS attack
DSL
DTLS (Datagram Transport Layer Security)
DTMF (Dual-Tone Multi-Frequency signaling)
Dynamic typing
ECMA
ECMAScript
Effective connection type
Element
Encapsulation
Encryption
Endianness
Engine
Entity
Entity header
Enumerated
eTLD
Event
Exception
EXIF
Expando
Fallback alignment
Falsy
Favicon
Federated identity
Fetch directive
Fetch metadata request header
Fingerprinting
Firefox OS
Firewall
First Contentful Paint (FCP)
First CPU idle
First Input Delay (FID)Deprecated
First Meaningful Paint (FMP)
First Paint (FP)
First-class Function
Flex
Flex Container
Flex Item
Flexbox
Flow relative values
Forbidden header name
Forbidden response header name
Fork
Fragmentainer
Frame rate (FPS)
FTP
FTU
Function
Fuzz testing
Gamut
Garbage collection
Gecko
General header
GIF
Git
Global object
Global scope
Global variable
Glyph
Google Chrome
GPL
GPU
Graceful degradation
Grid
Grid Areas
Grid Axis
Grid Cell
Grid Column
Grid container
Grid Lines
Grid Row
Grid Tracks
Gutters
gzip compression
Hash
Head
High-level programming language
HMAC
Hoisting
Host
Hotlink
Houdini
HPKP
HSTS
HTML
HTML color codes
HTML5
HTTP
HTTP Content
HTTP header
HTTP/2
HTTP/3
HTTPS
HTTPS RR
Hyperlink
Hypertext
IANA
ICANN
ICE
IDE
Idempotent
Identifier
Identity provider (IdP)
IDL
IETF
IIFE
IMAP
Immutable
IndexedDB
Information architecture
Inheritance
Ink overflow
Inline-level content
Input method editor
Inset properties
Instance
Interaction to Next Paint (INP)
Internationalization (i18n)
Internet
Interpolation
Intrinsic size
IP Address
IPv4
IPv6
IRC
ISO
ISP
ITU
Jank
Java
JavaScript
Jitter
JPEG
JSON
JSON type representation
Kebab case
Key
Keyword
Largest Contentful Paint (LCP)
Latency
Layout viewport
Lazy load
LGPL
Ligature
Literal
Local scope
Local variable
Locale
Localization
Logical properties
Long task
Loop
Lossless compression
Lossy compression
LTR (Left To Right)
Main Axis
Main thread
Markup
MathML
Media
Media query
Metadata
Method
Microsoft Edge
Microsoft Internet Explorer
Middleware
MIME
MIME type
Minification
MitM
Mixin
Mobile First
Modem
Modularity
Mozilla Firefox
Mutable
MVC
Namespace
NaN
NAT
Native
Navigation directive
Netscape Navigator
Network throttling
NNTP
Node
Node.js
Non-normative
Normative
Null
Nullish value
Number
Object
Object reference
OOP
OpenGL
OpenSSL
Opera Browser
Operand
Operator
Origin
OTA
OWASP
P2P
PAC
Packet
Page load time
Page prediction
Parameter
Parent object
Parse
Parser
Payload body
Payload header
PDF
Perceived performance
Percent-encoding
PHP
Physical properties
Pixel
Placeholder names
Plaintext
Plugin
PNG
Polyfill
Polymorphism
POP3
Port
Prefetch
Preflight request
Prerender
Presto
Primitive
Privileged
Privileged code
Progressive Enhancement
Progressive web apps
Promise
Property
Protocol
Prototype
Prototype-based programming
Proxy server
Pseudo-class
Pseudo-element
Pseudocode
Public-key cryptography
Python
Quality values
Quaternion
QUIC
RAIL
Random Number Generator
Raster image
Rate limit
RDF
Real User Monitoring (RUM)
Recursion
Reflow
Regular expression
Relying party
Render-blocking
Repaint
Replay attack
Repo
Reporting directive
Representation header
Request header
Resource Timing
Response header
Responsive web design
REST
RGB
RIL
Robots.txt
Round Trip Time (RTT)
Router
RSS
Rsync
RTCP (RTP Control Protocol)
RTF
RTL (Right to Left)
RTP (Real-time Transport Protocol) and SRTP (Secure RTP)
RTSP: Real-time streaming protocol
Ruby
Safe
Salt
Same-origin policy
SCM
Scope
Screen reader
Script-supporting element
Scroll boundary
Scroll chaining
Scroll container
Scroll snap
SCTP
SDK (Software Development Kit)
SDP
Search engine
Secure Context
Secure Sockets Layer (SSL)
Selector (CSS)
Self-Executing Anonymous Function
Semantics
SEO
Serializable object
Serialization
Server
Server Timing
Session Hijacking
SGML
Shadow tree
Shallow copy
Shim
Signature
SIMD
SISD
Site
Site map
SLD
Sloppy mode
Slug
Smoke Test
SMPTE (Society of Motion Picture and Television Engineers)
SMTP
Snake case
Snap positions
SOAP
Source map
SPA (Single-page application)
Specification
Speculative parsing
Speed index
SQL
SQL Injection
SRI
Stacking context
State machine
Statement
Static method
Static site generator (SSG)
Static typing
Sticky activation
Strict mode
String
Stringifier
STUN
Style origin
Stylesheet
Submit button
SVG
SVN
Symbol
Symmetric-key cryptography
Synchronous
Syntax
Syntax error
Synthetic monitoring
Table grid box
Table Wrapper Box
Tag
TCP
TCP handshake
TCP slow start
Telnet
Texel
The Khronos Group
Thread
Three js
Throttle
Time to first byte
Time to interactive
TLD
TOFU
Top layer
Transient activation
Transport Layer Security (TLS)
Tree shaking
Trident
Truthy
TTL
TURN
Type
Type coercion
Type conversion
TypeScript
UAAG
UDP (User Datagram Protocol)
UI
Undefined
Unicode
Unix time
URI
URL
URN
Usenet
User agent
UTF-8
UUID
UX
Validator
Value
Variable
Vendor Prefix
Viewport
Visual Viewport
Void element
VoIP
W3C
WAI
WCAG
Web performance
Web server
Web standards
WebAssembly
WebDAV
WebExtensions
WebGL
WebIDL
WebKit
WebM
WebP
WebRTC
WebSockets
WebVTT
WHATWG
Whitespace
WindowProxy
World Wide Web
Wrapper
XFormsDeprecated
XHTML
XInclude
XLink
XML
XMLHttpRequest (XHR)
XPath
XQuery
XSLT
Zstandard compression
Hoisting
JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables, classes, or imports to the top of their scope, prior to execution of the code.

Hoisting is not a term normatively defined in the ECMAScript specification. The spec does define a group of declarations as HoistableDeclaration, but this only includes function, function*, async function, and async function* declarations. Hoisting is often considered a feature of var declarations as well, although in a different way. In colloquial terms, any of the following behaviors may be regarded as hoisting:

Being able to use a variable's value in its scope before the line it is declared. ("Value hoisting")
Being able to reference a variable in its scope before the line it is declared, without throwing a ReferenceError, but the value is always undefined. ("Declaration hoisting")
The declaration of the variable causes behavior changes in its scope before the line in which it is declared.
The side effects of a declaration are produced before evaluating the rest of the code that contains it.
The four function declarations above are hoisted with type 1 behavior; var declaration is hoisted with type 2 behavior; let, const, and class declarations (also collectively called lexical declarations) are hoisted with type 3 behavior; import declarations are hoisted with type 1 and type 4 behavior.

Some prefer to see let, const, and class as non-hoisting, because the temporal dead zone strictly forbids any use of the variable before its declaration. This dissent is fine, since hoisting is not a universally-agreed term. However, the temporal dead zone can cause other observable changes in its scope, which suggests there's some form of hoisting:

js
Copy to Clipboard
const x = 1;
{
  console.log(x); // ReferenceError
  const x = 2;
}
If the const x = 2 declaration is not hoisted at all (as in, it only comes into effect when it's executed), then the console.log(x) statement should be able to read the x value from the upper scope. However, because the const declaration still "taints" the entire scope it's defined in, the console.log(x) statement reads the x from the const x = 2 declaration instead, which is not yet initialized, and throws a ReferenceError. Still, it may be more useful to characterize lexical declarations as non-hoisting, because from a utilitarian perspective, the hoisting of these declarations doesn't bring any meaningful features.

Note that the following is not a form of hoisting:

js
Copy to Clipboard
{
  var x = 1;
}
console.log(x); // 1
There's no "access before declaration" here; it's simply because var declarations are not scoped to blocks.


